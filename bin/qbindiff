#!/usr/bin/env python3
# builtin-imports
import logging
import os
from pathlib import Path

# Third-party imports
import click
import numpy as np
from tqdm import tqdm

# Local imports
from qbindiff.features import FEATURES, DEFAULT_FEATURES
from qbindiff.loader import LOADERS, LoaderType
from qbindiff import Program, QBinDiff, Mapping


def configure_logging(verbose: int):
    # first desactivate matplotlib logging
    logger = logging.getLogger("matplotlib")
    logger.setLevel(logging.WARNING)
    logging.basicConfig(format="[%(levelname)s] %(message)s", level=logging.INFO)
    np.warnings.filterwarnings("ignore")

    logger = logging.getLogger()
    logger.setLevel(logging.DEBUG if verbose >= 1 else logging.INFO)


def display_statistics(differ: QBinDiff, mapping: Mapping) -> None:
    nb_matches = mapping.nb_match
    similarity = mapping.similarity
    nb_squares = mapping.squares

    output = (
        "Score: {:.4f} | "
        "Similarity: {:.4f} | "
        "Squares: {:.0f} | "
        "Nb matches: {}\n".format(
            similarity + nb_squares, similarity, nb_squares, nb_matches
        )
    )
    output += (
        "Node cover:  {:.3f}% / {:.3f}% | "
        "Edge cover:  {:.3f}% / {:.3f}%\n".format(
            100 * nb_matches / len(differ.primary_adj_matrix),
            100 * nb_matches / len(differ.secondary_adj_matrix),
            100 * nb_squares / differ.primary_adj_matrix.sum(),
            100 * nb_squares / differ.secondary_adj_matrix.sum(),
        )
    )
    print(output)


DISTANCES = ("canberra", "correlation", "cosine", "euclidean")
FEATURES_KEYS = {x.key: x for x in FEATURES}

CONTEXT_SETTINGS = dict(help_option_names=["-h", "--help"], max_content_width=300)

DEFAULT_FEATURES = tuple(x.key for x in DEFAULT_FEATURES)
DEFAULT_DISTANCE = "canberra"
DEFAULT_SPARSITY_RATIO = 0.75
DEFAULT_TRADEOFF = 0.75
DEFAULT_EPSILON = 0.5
DEFAULT_MAXITER = 1000

LOADERS_KEYS = list(LOADERS.keys())

help_formats = f"The file format of the output file. Supported formats are [bindiff]. [default: bindiff]"
help_loaders = (
    f"Loader type to be used. Must be one of these {LOADERS_KEYS}. [default: binexport]"
)
help_features = """\b
The following features are available:
{}
[default: {}]""".format(
    "\n".join("  - {}: {}".format(x.key, x.__doc__) for x in FEATURES), DEFAULT_FEATURES
)
help_distance = f"""\b
The following distances are available {DISTANCES}
Features may be weighted by a positive value such as <feature>:<weight> [default: 1.0]
[default: {DISTANCES[0]}]"""


@click.command(context_settings=CONTEXT_SETTINGS)
@click.option(
    "-l",
    "--loader",
    type=click.Choice(LOADERS_KEYS),
    default="binexport",
    metavar="<loader>",
    help=help_loaders,
)
@click.option(
    "-f",
    "--features",
    type=str,
    default=DEFAULT_FEATURES,
    multiple=True,
    metavar="<feature>",
    help=help_features,
)
@click.option(
    "-d",
    "--distance",
    type=click.Choice(DISTANCES),
    default=DEFAULT_DISTANCE,
    metavar="<function>",
    help=help_distance,
)
@click.option(
    "-s",
    "--sparsity-ratio",
    type=float,
    default=DEFAULT_SPARSITY_RATIO,
    help="Ratio of least probable matches to ignore. Between 0.0 to 1.0 [default: %.02f]"
    % DEFAULT_SPARSITY_RATIO,
)
@click.option(
    "-t",
    "--tradeoff",
    type=float,
    default=DEFAULT_TRADEOFF,
    help="Tradeoff between function content (near 1.0) and call-graph information (near 0.0) [default: %.02f]"
    % DEFAULT_TRADEOFF,
)
@click.option(
    "-e",
    "--epsilon",
    type=float,
    default=DEFAULT_EPSILON,
    help="Relaxation parameter to enforce convergence [default: %.02f]"
    % DEFAULT_EPSILON,
)
@click.option(
    "-i",
    "--maxiter",
    type=int,
    default=DEFAULT_MAXITER,
    help="Maximum number of iteration for belief propagation [default: %d]"
    % DEFAULT_MAXITER,
)
@click.option(
    "-e1",
    "--executable1",
    "exec_primary",
    type=Path,
    help="Path to the primary raw executable. Must be provided if using qbinexport loader",
)
@click.option(
    "-e2",
    "--executable2",
    "exec_secondary",
    type=Path,
    help="Path to the secondary raw executable. Must be provided if using qbinexport loader",
)
@click.option(
    "-o",
    "--output",
    type=Path,
    help="Write output to PATH",
)
@click.option(
    "-ff",
    "--file-format",
    default="bindiff",
    type=click.Choice(["bindiff"]),
    help=help_formats,
)
@click.option("-v", "--verbose", count=True, help="Activate debugging messages")
@click.argument("primary", type=Path, metavar="<primary file>")
@click.argument("secondary", type=Path, metavar="<secondary file>")
def main(
    loader,
    features,
    distance,
    sparsity_ratio,
    tradeoff,
    epsilon,
    maxiter,
    exec_primary,
    exec_secondary,
    output,
    file_format,
    verbose,
    primary,
    secondary,
):
    """
    qBinDiff is an experimental binary diffing tool based on
    machine learning technics, namely Belief propagation.
    """

    configure_logging(verbose)

    if 0.0 > sparsity_ratio > 1:
        logging.warning(
            "[-] Sparsity ratio should be within 0..1 (set it to %.2f)"
            % DEFAULT_SPARSITY_RATIO
        )
        sparsity_ratio = DEFAULT_SPARSITY_RATIO

    if 0.0 > tradeoff > 1:
        logging.warning(
            "[-] Trade-off parameter should be within 0..1 (set it to %.2f)"
            % DEFAULT_TRADEOFF
        )
        tradeoff = DEFAULT_TRADEOFF

    if 0.0 > epsilon:
        logging.warning(
            "[-] Epsilon parameter should be positive (set it to %.3f)"
            % DEFAULT_EPSILON
        )
        epsilon = DEFAULT_EPSILON

    if not output.name:
        logging.warning("[-] You have not specified an output file")

    loader = LOADERS[loader]

    # Check that the executables have been provided
    if loader == LoaderType.qbinexport:
        if not (
            exec_primary
            and exec_secondary
            and os.path.exists(exec_primary)
            and os.path.exists(exec_secondary)
        ):
            logging.error(
                "When using the qbinexport loader you have to provide the raw binaries"
            )
            exit(1)
        logging.info(f"[+] Loading primary: {primary.name}")
        primary = Program(primary, loader, exec_primary)
        logging.info(f"[+] Loading secondary: {secondary.name}")
        secondary = Program(secondary, loader, exec_secondary)
    else:
        logging.info(f"[+] Loading primary: {primary.name}")
        primary = Program(primary, loader)
        logging.info(f"[+] Loading secondary: {secondary.name}")
        secondary = Program(secondary, loader)

    qbindiff = QBinDiff(
        primary,
        secondary,
        sparsity_ratio=sparsity_ratio,
        tradeoff=tradeoff,
        epsilon=epsilon,
        maxiter=maxiter,
    )

    if not features:
        logging.error("no feature provided")
        exit(1)

    for feature in set(features):
        weight = 1.0
        if ":" in feature:
            feature, weight = feature.split(":")
        if feature not in FEATURES_KEYS:
            logging.warning(f"Feature '{feature}' not recognized - ignored.")
            continue
        qbindiff.register_feature_extractor(FEATURES_KEYS[feature], float(weight))

    logging.info("[+] Initializing NAP")
    qbindiff.process()

    logging.info("[+] Computing NAP")
    for _ in tqdm(qbindiff.matching_iterator(), total=maxiter):
        pass

    display_statistics(qbindiff, qbindiff.mapping)

    if output.name:
        logging.info("[+] Saving")
        if file_format == "bindiff":
            qbindiff.export_to_bindiff(output)
        logging.info("[+] Mapping successfully saved to: %s" % output)


if __name__ == "__main__":
    main()
