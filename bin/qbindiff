#!/usr/bin/env python3
# coding: utf-8
import logging
import click
import numpy as np
from pathlib import Path
from tqdm import tqdm

from qbindiff.loader.types import LoaderType
from qbindiff.loader.program import Program
from qbindiff.differ.qbindiff import QBinDiff

from qbindiff.features.mnemonic import MnemonicSimple, MnemonicTyped, GroupsCategory
from qbindiff.features.graph import GraphNbBlock, GraphMeanInstBlock, GraphMeanDegree, \
                                    GraphDensity, GraphNbComponents, GraphDiameter, GraphTransitivity, GraphCommunities
from qbindiff.features.artefact import LibName, DatName, Constant, ImpName, Address
from qbindiff.features.topology import NbChildren, NbParents, NbFamily

# Import for types
from qbindiff.types import PathLike, Int


def configure_logging(verbose: Int):
    # first desactivate matplotlib logging
    logger = logging.getLogger('matplotlib')
    logger.setLevel(logging.WARNING)
    logging.basicConfig(format='[%(levelname)s] %(message)s', level=logging.INFO)
    numpy.warnings.filterwarnings('ignore')

    logger = logging.getLogger()
    logger.setLevel(logging.DEBUG if verbose >= 1 else logging.INFO)


def load_qbindiff_program(filename: PathLike) -> Program:
    program = Program(LoaderType.qbindiff.name, Path(filename) / "data", Path(filename) / "callgraph.json")
    logging.info("[+] %s loaded: %d functions" % (program.name, len(program)))
    return program


def load_binexport_program(filename: PathLike) -> Program:
    program = Program(LoaderType.binexport.name, filename)
    logging.info("[+] %s loaded: %d functions" % (program.name, len(program)))
    return program

def extract_function_anchors(primary: Program, secondary: Program) -> AddrAnchors:
    primary_names = {function.name: function.address for function in primary}
    secondary_names = {function.name: function.address for function in secondary}
    anchors = []
    for name in set(primary_names).intersection(secondary_names):
        anchors.append((primary_names[name], secondary_names[name]))
    return zip(*anchors)



LOADERS = list(x.name for x in LoaderType)
FEATURES = {MnemonicSimple,
            MnemonicTyped,
            GroupsCategory,
            GraphNbBlock,
            GraphMeanInstBlock,
            GraphMeanDegree,
            GraphDensity,
            GraphNbComponents,
            GraphDiameter,
            GraphTransitivity,
            GraphCommunities,
            LibName,
            DatName,
            Constant,
            ImpName,
            NbChildren,
            NbParents,
            NbParents,
            NbFamily,
            Address
            # New features should be added here
            }

FEATURES_KEYS = {x.name: x for x in FEATURES}
FEATURES_KEYS.update({x.key: x for x in FEATURES})  # also add short keys as a valid feature
DISTANCES = ['canberra', 'correlation', 'cosine', 'euclidean']

CONTEXT_SETTINGS = dict(help_option_names=['-h', '--help'], max_content_width=300)

DEFAULT_LOADER = LoaderType.binexport.name
DEFAULT_FEATURES = tuple(FEATURES_KEYS)
DEFAULT_DISTANCE = "canberra"
DEFAULT_SPARSITY_RATIO = 0.75
DEFAULT_MAXITER = 1000
DEFAULT_TRADEOFF = 0.75
DEFAULT_EPSILON = 0.05
DTYPE = np.float32

help_features = 'The following features are available [default: all]:\n{}\n'.format('\n'.join("- {}, {}: {}".format(x.key, x.name, x.__doc__) for x in FEATURES))
help_distance = 'The following distances are available [default: {}]:\n{}\n'.format(DISTANCES[0], '\n'.join('-d {}'.format(dist) for dist in DISTANCES))



@click.command(context_settings=CONTEXT_SETTINGS)
@click.option('-o', '--output', type=Path, default='',
              help="Output file [default: <primary>_vs_<secondary>.qbindiff]")
@click.option('-l', '--loader', type=click.Choice(LOADERS), default=DEFAULT_LOADER,
              help="Input files type between %s. [default loader: %s]" % (LOADERS, DEFAULT_LOADER))
@click.option('-f', '--features', type=str, default=DEFAULT_FEATURES, multiple=True,
              metavar="<feature>", help=help_features)
@click.option('-d', '--distance', type=click.Choice(DISTANCES), default=DEFAULT_DISTANCE,
              metavar="<function>", help=help_distance)
@click.option('-s', '--sparsity_ratio', type=float, default=DEFAULT_SPARSITY_RATIO,
              help="Ratio of least probable matches to ignore. Between 0.0 to 1.0 [default: %.02f]" % DEFAULT_SPARSITY_RATIO)
@click.option('-t', '--tradeoff', type=float, default=DEFAULT_TRADEOFF,
              help="Tradeoff between function content (near 1.0) and call-graph information (near 0.0) [default: %.02f]" % DEFAULT_TRADEOFF)
@click.option('-e', '--epsilon', type=float, default=DEFAULT_EPSILON,
              help="Relaxation parameter to enforce convergence [default: %.02f]" % DEFAULT_EPSILON)
@click.option('-i', '--maxiter', type=int, default=DEFAULT_MAXITER,
              help="Maximum number of iteration for belief propagation [default: %d]" % DEFAULT_MAXITER)
@click.option('-v', '--verbose', count=True, help="Activate debugging messages")
@click.argument("primary", type=Path, metavar="<primary file>")
@click.argument('secondary', type=Path, metavar="<secondary file>")
def main(output, loader, features, distance, sparsity_ratio, tradeoff, epsilon, maxiter, verbose, primary, secondary):
    """
    qBinDiff is an experimental binary diffing tool based on
    machine learning technics, namely Belief propagation.
    """

    configure_logging(verbose)

    if 0.0 > sparsity_ratio > 1:
        logging.warning("[-] Sparsity ratio should be within 0..1 (set it to %.2f)" % DEFAULT_SPARSITY_RATIO)
        sparsity_ratio = DEFAULT_SPARSITY_RATIO

    if 0.0 > tradeoff > 1:
        logging.warning("[-] Trade-off parameter should be within 0..1 (set it to %.2f)" % DEFAULT_TRADEOFF)
        tradeoff = DEFAULT_TRADEOFF

    if 0.0 > epsilon:
        logging.warning("[-] Epsilon parameter should be positive (set it to %.3f)" % DEFAULT_EPSILON)
        epsilon = DEFAULT_EPSILON

    if not output.name:
        output = Path('{}_vs_{}.qbindiff'.format(primary.stem, secondary.stem))

    # Preprocessing to extract features and filters functions
    logging.info("[+] Loading programs")
    if loader == "qbindiff":
        primary = load_qbindiff_program(primary)
        secondary = load_qbindiff_program(secondary)
    elif loader == "binexport":
        primary = load_binexport_program(primary)
        secondary = load_binexport_program(secondary)
    else:
        logging.error("[-] Diaphora loader not implemented yet..")
        exit(1)

    qbindiff = QBinDiff(primary, secondary)

    for feature in set(features):
        weight = 1.0
        if ':' in feature:
            feature, weight = feature.split(':')
        if feature not in FEATURES_KEYS:
            logging.warning("Feature '{}' not recognized - ignored.")
            continue
        qbindiff.register_feature(FEATURES_KEYS[feature], weight)

    anchors = extract_function_anchors(primary, secondary)

    logging.info("[+] Initializing NAP")
    qbindiff.initialize(qbindiff.primary, qbindiff.secondary, qbindiff.primary.callgraph, qbindiff.secondary.callgraph, qbindiff._visitor, distance, DTYPE, anchors)

    logging.info("[+] Computing NAP")
    for _ in tqdm(qbindiff.compute(sparsity_ratio, tradeoff, epsilon, maxiter), total=maxiter):
        pass

    logging.info("[+] Saving")
    qbindiff.save(output)
    logging.info("[+] Mapping successfully saved to: %s" % output)
    exit(0)

if __name__ == '__main__':
    main()
