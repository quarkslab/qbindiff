#!/usr/bin/env python3
# coding: utf-8

import logging
import os.path
import click
from tqdm import tqdm
from json import dump
import numpy

# Pop the directory of the script (to avoid import conflict with qbindiff (same name)
import sys
del sys.path[0]

from qbindiff.loader.program import Program
from qbindiff.differ.qbindiff import QBinDiff

from qbindiff.features.mnemonic import MnemonicSimple, MnemonicTyped, GroupsCategory
from qbindiff.features.graph import GraphNbBlock, GraphMeanInstBlock, GraphMeanDegree, \
        GraphDensity, GraphNbComponents, GraphDiameter, GraphTransitivity, GraphCommunities
from qbindiff.features.artefact import LibName, DatName, Constant, ImpName

from qbindiff.loader.types import LoaderType
from qbindiff.features.topology import NbChildren, NbParents, NbFamily


def configure_logging(verbose):
    # first desactivate matplotlib logging
    logger = logging.getLogger('matplotlib')
    logger.setLevel(logging.WARNING)
    logging.basicConfig(format='[%(levelname)s] %(message)s', level=logging.INFO)
    numpy.warnings.filterwarnings('ignore')

    logger = logging.getLogger()
    logger.setLevel(logging.DEBUG if verbose >= 1 else logging.INFO)


def load_qbindiff_program(f_path):
    p = Program(LoaderType.qbindiff.name, os.path.join(f_path, "data"), os.path.join(f_path, "callgraph.json"))
    logging.info("[+] %s loaded: %d functions" % (p.name, len(p)))
    return p


def load_binexport_program(file):
    p = Program(LoaderType.binexport.name, file)
    logging.info("[+] %s loaded: %d functions" % (p.name, len(p)))
    return p


LOADERS = list(x.name for x in LoaderType)
FEATURES = {MnemonicSimple,
            MnemonicTyped,
            GroupsCategory,
            GraphNbBlock,
            GraphMeanInstBlock,
            GraphMeanDegree,
            GraphDensity,
            GraphNbComponents,
            GraphDiameter,
            GraphTransitivity,
            GraphCommunities,
            LibName,
            DatName,
            Constant,
            ImpName,
            NbChildren,
            NbParents,
            NbFamily
            # New features should be added here
            }

FEATURES_KEYS = {x.name: x for x in FEATURES}
FEATURES_KEYS.update({x.key: x for x in FEATURES})  # also add short keys as a valid feature
DISTANCE = ['auto', 'correlation', 'cosine', 'euclidean']

CONTEXT_SETTINGS = dict(help_option_names=['-h', '--help'],
                        max_content_width=300)

DEFAULT_LOADER = LoaderType.binexport.name
DEFAULT_OUTPUT = "matching.json"
DEFAULT_DISTANCE = "auto"
DEFAULT_SIM_RATIO = .9
DEFAULT_SQ_RATIO = .75
DEFAULT_MAXITER = 80
DEFAULT_TRADEOFF = 0.5

help_features = """The following features are available:
"""+''.join("- %s, %s: %s\n" % (x.key, x.name, x.__doc__) for x in FEATURES)

help_distance = "Mathematical distance function between cosine and correlation [default: %s]" % DEFAULT_DISTANCE


@click.command(context_settings=CONTEXT_SETTINGS)
@click.option('-o', '--output', type=click.Path(), default=DEFAULT_OUTPUT,
              help="Output file matching [default: %s]" % DEFAULT_OUTPUT)
@click.option('-l', '--loader', type=click.Choice(LOADERS), default=DEFAULT_LOADER, metavar="<loader>",
              help="Input files type between %s. [default loader: %s]" % (LOADERS, DEFAULT_LOADER))
@click.option('-f', '--feature', type=click.Choice(FEATURES_KEYS), default=None, multiple=True,
              metavar="<feature>", help=help_features, required=True)
@click.option('-d', '--distance', type=click.Choice(DISTANCE), default=DEFAULT_DISTANCE,
              metavar="<function>", help=help_distance)
@click.option('-si', '--sim_ratio', type=float, default=DEFAULT_SIM_RATIO,
              help="Minimum function-based similarity ratio of matches to be considered. Between 0.0 to 1.0 [default: %.02f]" % DEFAULT_SIM_RATIO)
@click.option('-sq', '--sq_ratio', type=float, default=DEFAULT_SQ_RATIO,
              help="Minimum call-graph-based similarity ratio of matches to be considered. Between 0.0 to 1.0 [default: %.02f]" % DEFAULT_SQ_RATIO)
@click.option('-i', '--maxiter', type=int, default=DEFAULT_MAXITER,
              help="Maximum number of iteration for belief propagation [default: %d]" % DEFAULT_MAXITER)
@click.option('-t', '--tradeoff', type=float, default=DEFAULT_TRADEOFF,
              help="Tradeoff between function content (near 0.0) and callgraph informations (near 1.0) [default: %d]" % DEFAULT_TRADEOFF)
@click.option('--refine-match/--no-refine-match', default=True)
@click.option('-v', '--verbose', count=True, help="Activate debugging messages")
@click.argument("primary", type=click.Path(exists=True), metavar="<primary file>")
@click.argument('secondary', type=click.Path(exists=True), metavar="<secondary file>")
def main(output, loader, feature, distance, sim_ratio, sq_ratio, maxiter, tradeoff, refine_match, verbose, primary, secondary):
    """
    qBinDiff is an experimental binary diffing tool based on
    machine learning technics, namely Belief propagation.
    """

    configure_logging(verbose)

    if 0.0 > sim_ratio > 1:
        logging.warning("Similarity ratio should be within 0..1 (set it to %.2f)" % DEFAULT_SIM_RATIO)
        threshold = 1

    if 0.0 > sq_ratio > 1:
        logging.warning("Square ratio should be within 0..1 (set it to %.2f)" % DEFAULT_SQ_RATIO)
        sparsity = DEFAULT_THRESHOLD_SPARSITY

    if 0.0 > tradeoff > 1:  # verify that tradeoff
        logging.warning("Trade-off parameter should be within 0..1 (set it to %.2f)" % DEFAULT_TRADEOFF)
        tradeoff = DEFAULT_TRADEOFF

    # Preprocessing to extract features and filters functions
    logging.info("[+] loading programs")
    p1, p2 = None, None
    if loader == "qbindiff":
        p1 = load_qbindiff_program(primary)
        p2 = load_qbindiff_program(secondary)
    elif loader == "binexport":
        # checks here that selected features are supported
        unsupported_fts = [GroupsCategory.name]
        if [x for x in feature if x in unsupported_fts]:
            logging.warning("Useless feature %s for the binexport loader" % str(unsupported_fts))
        p1 = load_binexport_program(primary)
        p2 = load_binexport_program(secondary)
    else:
        logging.error("Diaphora loader not implemented yet..")
        exit(1)

    features = [FEATURES_KEYS[name] for name in feature]

    differ = QBinDiff(p1, p2)

    logging.info("[+] initialize messages")
    differ.initialize(features=features, distance=distance, sim_ratio=sim_ratio, sq_ratio=sq_ratio)

    logging.info("[+] compute messages")
    for _ in tqdm(differ.compute(tradeoff=tradeoff, maxiter=maxiter), total=maxiter):
        pass

    if refine_match:
        logging.info("[+] refine matching")
        differ.refine()

        #differ.matching.write_file(output)
        #logging.info("[+] matching successfully saved to: %s" % output)
        #exit(0)
    #else:
        #exit(1)

    with open(str(output), 'w') as f_out:
        dump(differ.matching, f_out)
    logging.info("[+] matching successfully saved to: %s" % output)
    exit(0)

if __name__ == '__main__':
    main()
