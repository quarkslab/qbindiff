#!/usr/bin/env python3
# coding: utf-8

import logging
import os.path
import click
from tqdm import tqdm
import json
import numpy

# Pop the directory of the script (to avoid import conflict with qbindiff (same name)
import sys
del sys.path[0]

from qbindiff.loader.program import Program
from qbindiff.features.mnemonic import MnemonicSimple, MnemonicTyped, GroupsCategory
from qbindiff.features.graph import GraphNbBlock, GraphMeanInstBlock, GraphMeanDegree, \
        GraphDensity, GraphNbComponents, GraphDiameter, GraphTransitivity, GraphCommunities
from qbindiff.features.artefact import LibName, DatName, Constant, ImpName
from qbindiff.differ.qbindiff import QBinDiff
from qbindiff.loader.types import LoaderType
from qbindiff.features.topology import NbChildren, NbParents, NbFamily

def configure_logging(verbose):
    # first desactivate matplotlib logging
    logger = logging.getLogger('matplotlib')
    logger.setLevel(logging.WARNING)
    logging.basicConfig(format='[%(levelname)s] %(message)s', level=logging.INFO)
    numpy.warnings.filterwarnings('ignore')

    logger = logging.getLogger()
    logger.setLevel(logging.DEBUG if verbose >= 1 else logging.INFO)


def load_qbindiff_program(f_path):
    p = Program(LoaderType.qbindiff.name, os.path.join(f_path, "data"), os.path.join(f_path, "callgraph.json"))
    logging.info("[+] %s loaded: %d functions" % (p.name, len(p)))
    return p


def load_binexport_program(file):
    p = Program(LoaderType.binexport.name, file)
    logging.info("[+] %s loaded: %d functions" % (p.name, len(p)))
    return p


LOADERS = list(x.name for x in LoaderType)
FEATURES = {MnemonicSimple,
            MnemonicTyped,
            GroupsCategory,
            GraphNbBlock,
            GraphMeanInstBlock,
            GraphMeanDegree,
            GraphDensity,
            GraphNbComponents,
            GraphDiameter,
            GraphTransitivity,
            GraphCommunities,
            LibName,
            DatName,
            Constant,
            ImpName,
            NbChildren,
            NbParents, 
            NbFamily
            # New features should be added here
            }

FEATURES_KEYS = {x.name: x for x in FEATURES}
FEATURES_KEYS.update({x.key: x for x in FEATURES})  # also add short keys as a valid feature
DISTANCE = ['auto', 'correlation', 'cosine', 'euclidean']

CONTEXT_SETTINGS = dict(help_option_names=['-h', '--help'],
                        max_content_width=300)

DEFAULT_LOADER = LoaderType.binexport.name
DEFAULT_OUTPUT = "matching.json"
DEFAULT_DISTANCE = "auto"
DEFAULT_THRESHOLD_GLOBAL = 0.0
DEFAULT_THRESHOLD_SPARSITY = 0.2
DEFAULT_MAXITER = 80
DEFAULT_TRADEOFF = 0.5

help_features = """The following features are available:
"""+''.join("- %s, %s: %s\n" % (x.key, x.name, x.__doc__) for x in FEATURES)

help_distance = "Mathematical distance function between cosine and correlation [default: %s]" % DEFAULT_DISTANCE


@click.command(context_settings=CONTEXT_SETTINGS)
@click.option('-o', '--output', type=click.Path(), default=DEFAULT_OUTPUT,
              help="Output file matching [default: %s]" % DEFAULT_OUTPUT)
@click.option('-l', '--loader', type=click.Choice(LOADERS), default=DEFAULT_LOADER, metavar="<loader>",
              help="Input files type between %s. [default loader: %s]" % (LOADERS, DEFAULT_LOADER))
@click.option('-f', '--feature', type=click.Choice(FEATURES_KEYS), default=None, multiple=True,
              metavar="<feature>", help=help_features, required=True)
@click.option('-d', '--distance', type=click.Choice(DISTANCE), default=DEFAULT_DISTANCE,
              metavar="<function>", help=help_distance)
@click.option('-t', '--threshold', type=float, default=DEFAULT_THRESHOLD_GLOBAL,
              help="Global distance threshold to keep matches between 0.0 to 1.0 [default: %.02f]" % DEFAULT_THRESHOLD_GLOBAL)
@click.option('-s', '--sparsity', type=float, default=DEFAULT_THRESHOLD_SPARSITY,
              help="Row based sparsity threshold to keep matches between 0.0 to 1.0 [default: %.02f]" % DEFAULT_THRESHOLD_SPARSITY)
@click.option('-i', '--maxiter', type=int, default=DEFAULT_MAXITER,
              help="Maximum number of iteration for belief propagation [default: %d]" % DEFAULT_MAXITER)
@click.option('-tr', '--tradeoff', type=float, default=DEFAULT_TRADEOFF,
              help="Tradeoff betwee callgraph (neat 0.0) and function content (near 1.0) [default: %d]" % DEFAULT_TRADEOFF)
@click.option('--refine-match/--no-refine-match', default=True)
@click.option('-v', '--verbose', count=True, help="Activate debugging messages")
@click.argument("primary", type=click.Path(exists=True), metavar="<primary file>")
@click.argument('secondary', type=click.Path(exists=True), metavar="<secondary file>")
def main(output, loader, feature, distance, threshold, sparsity, maxiter, tradeoff, refine_match, verbose, primary, secondary):
    """
    qBinDiff is an experimental binary diffing tool based on
    machine learning technics, namely Belief propagation.
    """

    configure_logging(verbose)

    if 0.0 > threshold > 1:  # check the threshold value to fit
        logging.warning("Threshold value should within 0..1 (set it to 1.0)")
        threshold = 1

    if 0.0 > sparsity > 1:
        logging.warning("Sparsity threshold value should be within 0..1 (set it to %.2f)" % DEFAULT_THRESHOLD_SPARSITY)
        sparsity = DEFAULT_THRESHOLD_SPARSITY

    if 0.0 > tradeoff > 1:  # verify that tradeoff
        logging.warning("Trade-off parameter should be positive (set it to %.2f)" % DEFAULT_TRADEOFF)
        tradeoff = DEFAULT_TRADEOFF

    # Preprocessing to extract features and filters functions
    logging.info("[+] loading programs")
    p1, p2 = None, None
    if loader == "qbindiff":
        p1 = load_qbindiff_program(primary)
        p2 = load_qbindiff_program(secondary)
    elif loader == "binexport":
        # checks here that selected features are supported
        unsupported_fts = [GroupsCategory.name]
        if [x for x in feature if x in unsupported_fts]:
            logging.warning("Useless feature %s for the binexport loader" % str(unsupported_fts))
        p1 = load_binexport_program(primary)
        p2 = load_binexport_program(secondary)
    else:
        logging.error("Diaphora loader not implemented yet..")
        exit(1)

    differ = QBinDiff(p1, p2, distance=distance, maxiter=maxiter, threshold=threshold, sparsity=sparsity, tradeoff=tradeoff)
    registered_ft = set()
    for name in feature:
        ft = FEATURES_KEYS[name]
        if ft in registered_ft:
            logging.warning("feature %s already registered (skip it)" % ft.name)
        else:
            differ.register_feature(ft())  # instanciate it
            registered_ft.add(ft)

    if differ.initialize():
        logging.info("[+] starts NAQP computation")
        for _ in tqdm(differ.run_iter(match_refine=refine_match), total=maxiter):
            pass

        differ.matching.write_file(output)
        logging.info("[+] matching successfully saved to: %s" % output)
        exit(0)
    else:
        exit(1)


if __name__ == '__main__':
    main()
